---
phase: 03-legacy-edge-function-migration
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - proto/worldmonitor/economic/v1/get_macro_signals.proto
  - proto/worldmonitor/economic/v1/service.proto
  - api/server/worldmonitor/economic/v1/handler.ts
  - src/components/MacroSignalsPanel.ts
  - api/macro-signals.js
  - src/generated/client/worldmonitor/economic/v1/service_client.ts
  - src/generated/server/worldmonitor/economic/v1/service_server.ts
  - docs/api/EconomicService.openapi.yaml
  - docs/api/EconomicService.openapi.json
autonomous: true
requirements:
  - CLEAN-02
  - DOMAIN-04
  - DOMAIN-10

must_haves:
  truths:
    - "Macro signals work via EconomicService.GetMacroSignals RPC instead of /api/macro-signals"
    - "All 7 signal types (liquidity, flow structure, macro regime, technical trend, hash rate, mining cost, fear/greed) computed identically"
    - "In-memory cache (5min TTL) behavior preserved"
    - "BUY/CASH/UNKNOWN verdict logic preserved"
    - "Proto messages match the existing JSON response shape with nested signals and sparklines"
  artifacts:
    - path: "proto/worldmonitor/economic/v1/get_macro_signals.proto"
      provides: "GetMacroSignalsRequest/Response proto messages with nested signal types"
      contains: "GetMacroSignalsRequest"
    - path: "api/server/worldmonitor/economic/v1/handler.ts"
      provides: "getMacroSignals RPC handler with 6-source parallel fetch"
      contains: "getMacroSignals"
    - path: "src/components/MacroSignalsPanel.ts"
      provides: "Consumer rewired to EconomicServiceClient"
      contains: "EconomicServiceClient"
  key_links:
    - from: "src/components/MacroSignalsPanel.ts"
      to: "api/server/worldmonitor/economic/v1/handler.ts"
      via: "EconomicServiceClient.getMacroSignals()"
      pattern: "client\\.getMacroSignals|getMacroSignals"
---

<objective>
Migrate the macro-signals endpoint to the economic domain as a GetMacroSignals RPC (step 6).

Purpose: Consolidate the complex macro-signals endpoint (6 upstream APIs, 7 signal computations, sparklines) into a typed sebuf RPC while preserving identical behavior.
Output: Working GetMacroSignals RPC, legacy macro-signals.js deleted, consumer using EconomicServiceClient.
</objective>

<execution_context>
@/Users/sebastienmelki/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastienmelki/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-legacy-edge-function-migration/03-RESEARCH.md
@api/macro-signals.js
@src/components/MacroSignalsPanel.ts
@api/server/worldmonitor/economic/v1/handler.ts
@proto/worldmonitor/economic/v1/service.proto
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GetMacroSignals proto + implement handler</name>
  <files>
    proto/worldmonitor/economic/v1/get_macro_signals.proto
    proto/worldmonitor/economic/v1/service.proto
    api/server/worldmonitor/economic/v1/handler.ts
  </files>
  <action>
1. Create `proto/worldmonitor/economic/v1/get_macro_signals.proto` with nested messages matching the JSON shape:

   ```protobuf
   syntax = "proto3";
   package worldmonitor.economic.v1;
   import "sebuf/ts/options.proto";

   message GetMacroSignalsRequest {}

   message GetMacroSignalsResponse {
     string timestamp = 1;       // ISO 8601 string (matches legacy)
     string verdict = 2;         // "BUY", "CASH", "UNKNOWN"
     int32 bullish_count = 3;
     int32 total_count = 4;
     MacroSignals signals = 5;
     MacroMeta meta = 6;
     bool unavailable = 7;
   }

   message MacroSignals {
     LiquiditySignal liquidity = 1;
     FlowStructureSignal flow_structure = 2;
     MacroRegimeSignal macro_regime = 3;
     TechnicalTrendSignal technical_trend = 4;
     HashRateSignal hash_rate = 5;
     MiningCostSignal mining_cost = 6;
     FearGreedSignal fear_greed = 7;
   }

   message LiquiditySignal {
     string status = 1;          // "SQUEEZE", "NORMAL", "UNKNOWN"
     optional double value = 2;  // JPY ROC 30d
     repeated double sparkline = 3;
   }

   message FlowStructureSignal {
     string status = 1;
     optional double btc_return_5 = 2;
     optional double qqq_return_5 = 3;
   }

   message MacroRegimeSignal {
     string status = 1;
     optional double qqq_roc_20 = 2;
     optional double xlp_roc_20 = 3;
   }

   message TechnicalTrendSignal {
     string status = 1;
     optional double btc_price = 2;
     optional double sma_50 = 3;
     optional double sma_200 = 4;
     optional double vwap_30d = 5;
     optional double mayer_multiple = 6;
     repeated double sparkline = 7;
   }

   message HashRateSignal {
     string status = 1;
     optional double change_30d = 2;
   }

   message MiningCostSignal {
     string status = 1;
   }

   message FearGreedHistoryEntry {
     int32 value = 1;
     string date = 2;
   }

   message FearGreedSignal {
     string status = 1;
     optional int32 value = 2;
     repeated FearGreedHistoryEntry history = 3;
   }

   message MacroMeta {
     repeated double qqq_sparkline = 1;
   }
   ```

   **Note:** Use `optional` for nullable numeric fields (null in legacy = absent in proto). Use `string` for timestamp (legacy returns ISO string, not epoch ms). The `unavailable` field maps to the fallback result.

2. Add RPC to `proto/worldmonitor/economic/v1/service.proto`:
   - Import `get_macro_signals.proto`
   - Add: `rpc GetMacroSignals(GetMacroSignalsRequest) returns (GetMacroSignalsResponse) { option (sebuf.http.config) = {path: "/get-macro-signals"}; }`

3. Run `cd proto && buf generate`

4. Implement `getMacroSignals` handler in `api/server/worldmonitor/economic/v1/handler.ts`:

   Port ALL logic from `api/macro-signals.js` exactly:

   a. **In-memory cache** — module-level `let cachedResponse` + `let cacheTimestamp` with 300s (5min) TTL. Exact same pattern as legacy.

   b. **fetchJSON helper** — with 8000ms AbortSignal timeout

   c. **Computation helpers** — port exactly:
      - `rateOfChange(prices, days)` — percentage change
      - `sma(prices, period)` — simple moving average
      - `extractClosePrices(chart)` — Yahoo Finance chart parsing
      - `extractVolumes(chart)` — volume parsing
      - `extractAlignedPriceVolume(chart)` — aligned price/volume pairs

   d. **6 parallel fetches** via Promise.allSettled:
      - Yahoo Finance: JPY=X, BTC-USD, QQQ, XLP (range=1y, interval=1d)
      - Alternative.me Fear & Greed (limit=30)
      - Mempool.space hashrate (1m)

   e. **7 signal computations** — exact same logic:
      1. Liquidity: JPY 30d ROC, SQUEEZE/NORMAL threshold at -2
      2. Flow Structure: BTC vs QQQ 5d return, gap > 5 = PASSIVE GAP
      3. Macro Regime: QQQ vs XLP 20d ROC, RISK-ON/DEFENSIVE
      4. Technical Trend: BTC vs SMA50, VWAP30d, Mayer multiple (BTC/SMA200)
      5. Hash Rate: 1m change, GROWING/DECLINING/STABLE at +/-3%
      6. Mining Cost: BTC price thresholds (60k/40k), PROFITABLE/TIGHT/SQUEEZE
      7. Fear & Greed: value and 30d history

   f. **Verdict** — bullishCount / totalCount >= 0.57 = BUY, else CASH

   g. **Sparklines** — last 30 prices for BTC, QQQ, JPY

   h. **Fallback** — `buildFallbackResult()` with all UNKNOWN statuses and unavailable=true, returned on error

   i. **Error handling** — on catch, return cached or fallback (not HTTP error)

   **CRITICAL:** Port every formula, threshold, and field mapping exactly. No improvements, no rounding changes, no renamed fields.
  </action>
  <verify>
`cd proto && buf lint` passes. `npx tsc --noEmit` passes. Proto file has all 10 message types. Handler has getMacroSignals method with 6 parallel fetches and 7 signal computations.
  </verify>
  <done>GetMacroSignals proto defined with full nested signal structure. Handler implements all 7 signal computations with 6-source parallel fetch, in-memory caching, and fallback.</done>
</task>

<task type="auto">
  <name>Task 2: Rewire MacroSignalsPanel consumer + delete legacy file</name>
  <files>
    src/components/MacroSignalsPanel.ts
    api/macro-signals.js
  </files>
  <action>
1. Read `src/components/MacroSignalsPanel.ts` to understand the current fetch pattern for `/api/macro-signals`

2. Rewire to use EconomicServiceClient:
   - Import `EconomicServiceClient` from `@/generated/client/worldmonitor/economic/v1/service_client`
   - Create client: `new EconomicServiceClient('', { fetch: fetch.bind(globalThis) })`
   - Replace `fetch('/api/macro-signals')` with `client.getMacroSignals({})`
   - Map the proto response fields to match existing usage:
     - Proto uses snake_case (flow_structure, btc_return_5, etc.) — the generated client should auto-convert to camelCase, but verify and adapt if needed
     - `optional` fields in proto map to `value | undefined` in TypeScript — handle with `?? null` where the consumer expects `null`
   - The response shape should be nearly identical since proto messages mirror the JSON structure

3. Delete `api/macro-signals.js`

4. Run `npx tsc --noEmit`

5. Commit: `feat(03-03): migrate macro-signals to economic GetMacroSignals RPC`
  </action>
  <verify>
`npx tsc --noEmit` passes. `api/macro-signals.js` deleted. `grep -r 'macro-signals' src/components/MacroSignalsPanel.ts` shows no fetch to legacy endpoint. EconomicServiceClient is used instead.
  </verify>
  <done>MacroSignalsPanel uses EconomicService.GetMacroSignals RPC. Legacy api/macro-signals.js deleted.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — full TypeScript compilation passes
2. `api/macro-signals.js` deleted
3. `src/components/MacroSignalsPanel.ts` uses `EconomicServiceClient.getMacroSignals()`
4. Proto has full nested signal structure matching legacy JSON shape
5. Handler has 6 parallel fetches, 7 signal computations, in-memory cache, fallback
</verification>

<success_criteria>
- Step 6 complete — macro-signals consolidated into GetMacroSignals RPC
- All 7 signal computations preserved identically
- In-memory cache (5min TTL) preserved
- BUY/CASH verdict logic preserved
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/03-legacy-edge-function-migration/03-03-SUMMARY.md`
</output>

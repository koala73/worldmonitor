---
phase: 02-server-runtime
plan: 03
type: execute
wave: 1
depends_on: ["02-02"]
files_modified:
  - scripts/build-sidecar-sebuf.mjs
  - package.json
  - .gitignore
  - .planning/REQUIREMENTS.md
autonomous: true
requirements:
  - SERVER-05
gap_closure: true

must_haves:
  truths:
    - "Tauri sidecar discovers and loads the compiled sebuf catch-all gateway bundle via buildRouteTable()"
    - "POST to /api/seismology/v1/list-earthquakes through the sidecar returns earthquake data from the compiled bundle handler"
    - "npm run build produces api/[[...path]].js as a side-effect, ready for Tauri bundling"
  artifacts:
    - path: "scripts/build-sidecar-sebuf.mjs"
      provides: "esbuild invocation that compiles api/[[...path]].ts + all TS dependencies into a single ESM .js bundle"
      min_lines: 15
    - path: "api/[[...path]].js"
      provides: "Compiled catch-all gateway bundle consumable by the sidecar's .js-only file filter"
    - path: "package.json"
      provides: "build:sidecar-sebuf script and updated build script that includes it"
  key_links:
    - from: "api/[[...path]].js"
      to: "src-tauri/sidecar/local-api-server.mjs"
      via: "buildRouteTable() discovers .js files in api/ directory"
      pattern: "entry\\.name\\.endsWith.*\\.js"
    - from: "scripts/build-sidecar-sebuf.mjs"
      to: "api/[[...path]].ts"
      via: "esbuild entryPoint"
      pattern: "api/\\[\\[...path\\]\\]\\.ts"
---

<objective>
Close SERVER-05 gap: compile the sebuf catch-all gateway TypeScript into a `.js` bundle so the Tauri sidecar can discover and load it.

Purpose: The Tauri sidecar (`local-api-server.mjs`) only discovers `.js` files via `buildRouteTable()`. The new catch-all gateway `api/[[...path]].ts` is TypeScript with no compiled `.js` counterpart. This plan adds an esbuild compilation step that bundles the gateway and all its TypeScript dependencies into a single `api/[[...path]].js` file that the sidecar naturally picks up via its existing file discovery and `[[...path]]` catch-all route matching.

Output: `scripts/build-sidecar-sebuf.mjs` build script, compiled `api/[[...path]].js` bundle, updated `package.json` scripts.
</objective>

<execution_context>
@/Users/sebastienmelki/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastienmelki/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-server-runtime/02-02-SUMMARY.md

Key files for understanding the gap:
@api/[[...path]].ts — The TypeScript catch-all gateway (entrypoint to compile)
@api/server/router.ts — Route matcher (dependency to bundle)
@api/server/cors.ts — CORS headers (dependency to bundle)
@api/server/error-mapper.ts — Error mapper (dependency to bundle)
@api/server/worldmonitor/seismology/v1/handler.ts — Seismology handler (dependency to bundle)
@src/generated/server/worldmonitor/seismology/v1/service_server.ts — Generated routes (dependency to bundle)
@src-tauri/sidecar/local-api-server.mjs — The sidecar that discovers .js files (lines 164-189: buildRouteTable, line 177: .js filter)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add esbuild compilation step for sebuf sidecar gateway bundle</name>
  <files>
    scripts/build-sidecar-sebuf.mjs
    package.json
    .gitignore
  </files>
  <action>
    1. Install esbuild as a devDependency: `npm install --save-dev esbuild`

    2. Create `scripts/build-sidecar-sebuf.mjs` — a Node.js script that uses the esbuild JavaScript API to bundle the catch-all gateway:
       - Entry point: `api/[[...path]].ts`
       - Output: `api/[[...path]].js`
       - Format: `esm` (the sidecar is ESM — `package.json` has `"type": "module"`)
       - Bundle: `true` (inline all TypeScript imports: router.ts, cors.ts, error-mapper.ts, handler.ts, service_server.ts)
       - Platform: `node` (the sidecar runs in Node.js, not browser — ensures `fetch`, `Request`, `Response` globals are used from Node.js)
       - Target: `node18` (minimum Node.js version per sidecar docs)
       - The script must strip TypeScript types and resolve all relative imports into a single self-contained .js file
       - Print a success message with output file size for build logs
       - Exit with non-zero on failure

    3. Add npm script to `package.json`:
       - Add `"build:sidecar-sebuf": "node scripts/build-sidecar-sebuf.mjs"` to scripts section
       - Update `"build"` from `"tsc && vite build"` to `"tsc && vite build && npm run build:sidecar-sebuf"`
       - This ensures every `tauri build` (which runs `npm run build` via beforeBuildCommand) also produces the compiled bundle

    4. Add `api/[[...path]].js` to `.gitignore` — it is a build artifact, not source code. Use the exact line:
       ```
       # Compiled sebuf gateway bundle (built by scripts/build-sidecar-sebuf.mjs)
       api/[[...path]].js
       ```

    5. Run `npm run build:sidecar-sebuf` to verify the compilation succeeds and `api/[[...path]].js` exists.
       - Confirm the output file is a valid ESM module with a `default` export function
       - Confirm it does NOT import any `.ts` files (all inlined)

    WHY esbuild specifically (not tsc):
    - tsc with noEmit:false would produce separate .js files for every TS module; the sidecar needs a single self-contained file because it imports by module path, not by package resolution
    - esbuild is already a transitive dependency of Vite (no new download needed, just the explicit devDependency entry)
    - esbuild handles TypeScript stripping + bundling in a single pass, ~50ms
  </action>
  <verify>
    - `npm run build:sidecar-sebuf` exits with code 0
    - `api/[[...path]].js` exists and is >1KB (contains inlined handler code)
    - `node -e "import('./api/[[...path]].js').then(m => console.log(typeof m.default))"` prints `function`
    - `grep -c "import " "api/[[...path]].js"` returns 0 (no remaining TS imports — all bundled)
    - `git status` shows `api/[[...path]].js` is NOT tracked (gitignored)
  </verify>
  <done>
    `npm run build:sidecar-sebuf` compiles api/[[...path]].ts into a self-contained api/[[...path]].js ESM bundle.
    The bundle exports a default handler function.
    The build script runs as part of `npm run build` (and therefore `tauri build`).
    The compiled .js file is gitignored as a build artifact.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify sidecar discovery and update REQUIREMENTS.md</name>
  <files>
    .planning/REQUIREMENTS.md
  </files>
  <action>
    1. Verify the sidecar will discover the compiled bundle by running a quick validation:
       - The sidecar's `buildRouteTable()` walks `api/` recursively, filters `.js` files, and computes `routePath` as the relative path minus `.js` extension.
       - For `api/[[...path]].js`, the routePath will be `[[...path]]` which matches the `[[...` catch-all pattern in `matchRoute()` and gets the lowest priority score (0) from `routePriority()`.
       - The sidecar calls `mod.default(request)` on matched modules — the compiled bundle exports `default async function handler(request: Request)`.
       - Confirm this chain works by checking: `node -e "import('./api/[[...path]].js').then(m => { const r = new Request('http://localhost/api/seismology/v1/list-earthquakes', {method:'POST', body:'{}', headers:{'content-type':'application/json'}}); m.default(r).then(res => console.log('status:', res.status)) })"`
       - Expected: prints `status: 200` (or 502 if USGS is unreachable, which is fine — proves the handler runs)

    2. Update `.planning/REQUIREMENTS.md`:
       - SERVER-05 line already shows `[x]` and `Complete` — this is now accurate after the bundle compilation step
       - Add a note below the SERVER-05 line: `  (closed via gap plan 02-03: esbuild compiles api/[[...path]].ts to .js bundle for sidecar discovery)`
       - No status change needed since it was already marked Complete (prematurely); now it's genuinely complete

    3. Verify no regressions:
       - Run `npm run typecheck:api` to confirm TypeScript checking still passes
       - Run `npm run build` to confirm full build pipeline works (tsc + vite build + sidecar-sebuf)
  </action>
  <verify>
    - Invoking the compiled bundle's default export with a POST Request to a sebuf path returns a Response (status 200 or 502)
    - `npm run typecheck:api` passes with 0 errors
    - `npm run build` completes successfully
    - REQUIREMENTS.md has gap closure note on SERVER-05
  </verify>
  <done>
    The compiled api/[[...path]].js bundle is confirmed loadable by the sidecar's module import pattern.
    REQUIREMENTS.md accurately reflects SERVER-05 gap closure.
    Full build pipeline passes end-to-end.
  </done>
</task>

</tasks>

<verification>
1. `npm run build:sidecar-sebuf` compiles the TypeScript catch-all gateway into a self-contained .js bundle
2. `api/[[...path]].js` is a valid ESM module exporting a default handler function
3. The sidecar's `buildRouteTable()` will discover `api/[[...path]].js` (matches .js filter, computes [[...path]] routePath)
4. The sidecar's `matchRoute()` matches any `/api/{domain}/v1/*` path to the catch-all
5. The sidecar's `dispatch()` calls `mod.default(request)` which hits the compiled handler
6. `npm run build` includes the sidecar-sebuf step (verified by `api/[[...path]].js` existence after build)
7. `npm run typecheck:api` still passes (no regressions)
</verification>

<success_criteria>
- SERVER-05 gap is closed: Tauri sidecar can discover and load the compiled sebuf gateway bundle
- Zero sidecar code changes required (leverages existing buildRouteTable + matchRoute + catch-all routing)
- Build pipeline produces the bundle automatically during `npm run build` / `tauri build`
- No regressions in typecheck or existing build steps
</success_criteria>

<output>
After completion, create `.planning/phases/02-server-runtime/02-03-SUMMARY.md`
</output>

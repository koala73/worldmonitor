---
phase: 04-v1-milestone-cleanup
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/earthquakes.ts
  - src/services/wildfires/index.ts
  - src/services/climate/index.ts
  - src/services/maritime/index.ts
  - src/services/summarization.ts
  - src/services/gdelt-intel.ts
autonomous: true
requirements: [CLIENT-03]

must_haves:
  truths:
    - "All 6 remaining domains have circuit breakers wrapping their sebuf client RPC calls"
    - "Seismology service wraps listEarthquakes in breaker.execute with empty-array fallback"
    - "Wildfire service wraps listFireDetections in breaker.execute, replacing the manual try/catch"
    - "Climate service wraps listClimateAnomalies in breaker.execute, replacing the manual try/catch"
    - "Maritime service wraps client.getVesselSnapshot in breaker.execute on the proto RPC path only"
    - "Summarization service wraps newsClient.summarizeArticle calls in breaker.execute per-provider"
    - "GDELT intel service wraps client.searchGdeltDocuments in breaker.execute"
    - "TypeScript compiles without errors after all changes"
  artifacts:
    - path: "src/services/earthquakes.ts"
      provides: "Seismology circuit breaker"
      contains: "createCircuitBreaker"
    - path: "src/services/wildfires/index.ts"
      provides: "Wildfire circuit breaker"
      contains: "createCircuitBreaker"
    - path: "src/services/climate/index.ts"
      provides: "Climate circuit breaker"
      contains: "createCircuitBreaker"
    - path: "src/services/maritime/index.ts"
      provides: "Maritime circuit breaker"
      contains: "createCircuitBreaker"
    - path: "src/services/summarization.ts"
      provides: "News/summarization circuit breaker"
      contains: "createCircuitBreaker"
    - path: "src/services/gdelt-intel.ts"
      provides: "Intelligence/GDELT circuit breaker"
      contains: "createCircuitBreaker"
  key_links:
    - from: "src/services/earthquakes.ts"
      to: "@/utils/circuit-breaker"
      via: "import createCircuitBreaker"
      pattern: "import.*createCircuitBreaker.*from.*@/utils"
    - from: "src/services/wildfires/index.ts"
      to: "@/utils/circuit-breaker"
      via: "import createCircuitBreaker"
      pattern: "import.*createCircuitBreaker.*from.*@/utils"
    - from: "src/services/maritime/index.ts"
      to: "@/utils/circuit-breaker"
      via: "import createCircuitBreaker"
      pattern: "import.*createCircuitBreaker.*from.*@/utils"
---

<objective>
Add circuit breaker coverage to the 6 remaining domains that lack it: seismology, wildfire, climate, maritime, news (summarization.ts), and intelligence (gdelt-intel.ts).

Purpose: Satisfy CLIENT-03 requirement -- all 17/17 domains have circuit breakers wrapping their sebuf client calls, providing automatic failure tracking, cooldown, cached fallback, and offline mode support uniformly across the application.
Output: Six modified service files, each using `createCircuitBreaker` from `@/utils` with `breaker.execute()` wrapping their RPC calls.
</objective>

<execution_context>
@/Users/sebastienmelki/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastienmelki/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-v1-milestone-cleanup/04-RESEARCH.md
@src/utils/circuit-breaker.ts
@src/services/cyber/index.ts
@src/services/earthquakes.ts
@src/services/wildfires/index.ts
@src/services/climate/index.ts
@src/services/maritime/index.ts
@src/services/summarization.ts
@src/services/gdelt-intel.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add circuit breakers to seismology, wildfire, climate, and maritime</name>
  <files>
    src/services/earthquakes.ts
    src/services/wildfires/index.ts
    src/services/climate/index.ts
    src/services/maritime/index.ts
  </files>
  <action>
    Use the established pattern from `src/services/cyber/index.ts` as reference: `import { createCircuitBreaker } from '@/utils'`, create typed breaker, wrap RPC calls in `breaker.execute(fn, fallback)`.

    **1. src/services/earthquakes.ts** (simplest case)

    Add import: `import { createCircuitBreaker } from '@/utils';`
    Add to imports from service_client: `type ListEarthquakesResponse`
    Create breaker: `const breaker = createCircuitBreaker<ListEarthquakesResponse>({ name: 'Seismology' });`
    Define fallback: `const emptyFallback: ListEarthquakesResponse = { earthquakes: [] };`
    In `fetchEarthquakes()`, wrap the client call:
    ```typescript
    const response = await breaker.execute(async () => {
      return client.listEarthquakes({ minMagnitude: 0 });
    }, emptyFallback);
    ```

    **2. src/services/wildfires/index.ts** (replace try/catch)

    Add import: `import { createCircuitBreaker } from '@/utils';`
    Add to imports from service_client: `type ListFireDetectionsResponse`
    Create breaker: `const breaker = createCircuitBreaker<ListFireDetectionsResponse>({ name: 'Wildfires' });`
    Define fallback: `const emptyFallback: ListFireDetectionsResponse = { fireDetections: [] };`
    In `fetchAllFires()`, replace the existing try/catch block. The breaker handles both failure tracking and fallback. Wrap the `client.listFireDetections({})` call in `breaker.execute()`. The rest of the function (region grouping, return) stays the same. When the breaker returns the fallback (empty fireDetections), the existing `detections.length === 0` check handles the skipped case.

    **3. src/services/climate/index.ts** (replace try/catch, handle `ok` field)

    Add import: `import { createCircuitBreaker } from '@/utils';`
    Add to imports from service_client: `type ListClimateAnomaliesResponse`
    Create breaker: `const breaker = createCircuitBreaker<ListClimateAnomaliesResponse>({ name: 'Climate Anomalies' });`
    Define fallback: `const emptyFallback: ListClimateAnomaliesResponse = { anomalies: [] };`
    In `fetchClimateAnomalies()`, replace the try/catch. Use `breaker.execute()` to wrap the `client.listClimateAnomalies()` call. After the execute call, apply the existing `.map(toDisplayAnomaly).filter(...)` chain. The `ok` field should always be `true` -- the breaker returns cached or fallback data gracefully. If there's a concern, you can check `breaker.getDataState().mode` to set `ok: false` when mode is 'unavailable', but the simpler approach is to always return `ok: true` since the breaker's cached/fallback path is intentional graceful degradation.

    **4. src/services/maritime/index.ts** (wrap proto RPC only, not raw relay)

    Add import: `import { createCircuitBreaker } from '@/utils';`
    Import the response type: `type GetVesselSnapshotResponse` from the service client import line (add to existing import).
    Create breaker: `const snapshotBreaker = createCircuitBreaker<GetVesselSnapshotResponse>({ name: 'Maritime Snapshot' });`
    Define fallback: `const emptySnapshotFallback: GetVesselSnapshotResponse = { snapshot: undefined };`

    In `fetchSnapshotPayload()`, wrap ONLY the proto RPC path (the `!includeCandidates` branch). The existing code at lines 202-220 has a try block that calls `client.getVesselSnapshot({})` and falls back to `fetchRawRelaySnapshot(false)` on catch. Replace this with:
    ```typescript
    const response = await snapshotBreaker.execute(async () => {
      return client.getVesselSnapshot({});
    }, emptySnapshotFallback);
    ```
    Then check `response.snapshot` -- if present, convert to legacy format as the existing code does. If `response.snapshot` is undefined (fallback), fall through to `fetchRawRelaySnapshot(false)` as the existing catch did. This preserves the raw relay fallback while adding circuit breaker tracking to the proto RPC path.

    IMPORTANT: Do NOT wrap the candidateReports path (raw relay). That path is for military vessel tracking and does not use the proto client.
  </action>
  <verify>
    1. `grep -c 'createCircuitBreaker' src/services/earthquakes.ts` returns 1
    2. `grep -c 'createCircuitBreaker' src/services/wildfires/index.ts` returns 1
    3. `grep -c 'createCircuitBreaker' src/services/climate/index.ts` returns 1
    4. `grep -c 'createCircuitBreaker' src/services/maritime/index.ts` returns 1
    5. `grep -c 'try {' src/services/wildfires/index.ts` returns 0 (try/catch replaced by breaker)
    6. `grep -c 'try {' src/services/climate/index.ts` returns 0 (try/catch replaced by breaker)
    7. `npx tsc --noEmit` passes
  </verify>
  <done>Seismology, wildfire, climate, and maritime service modules all use createCircuitBreaker wrapping their sebuf client RPC calls. Manual try/catch blocks in wildfire and climate are replaced. Maritime breaker wraps only the proto RPC path, preserving raw relay fallback.</done>
</task>

<task type="auto">
  <name>Task 2: Add circuit breakers to summarization (news) and gdelt-intel (intelligence)</name>
  <files>
    src/services/summarization.ts
    src/services/gdelt-intel.ts
  </files>
  <action>
    These are the underlying service files that `news/index.ts` and `intelligence/index.ts` re-export from. The breakers go here, not in the wrapper modules.

    **1. src/services/summarization.ts** (news domain)

    The summarization module has a multi-provider fallback chain where each provider calls `newsClient.summarizeArticle()`. The circuit breaker should wrap the individual RPC call within `tryApiProvider()`, not the entire chain (the chain itself IS the resilience pattern).

    Add import: `import { createCircuitBreaker } from '@/utils';`
    Import the response type: add `type SummarizeArticleResponse` to existing import if not already imported (check -- it IS already imported on line 14).
    Create breaker: `const summaryBreaker = createCircuitBreaker<SummarizeArticleResponse>({ name: 'News Summarization' });`
    Define fallback: `const emptySummaryFallback: SummarizeArticleResponse = { summary: '', provider: '', model: '', cached: false, skipped: false, fallback: true };`

    In `tryApiProvider()`, wrap the `newsClient.summarizeArticle()` call (currently line 54) inside `summaryBreaker.execute()`. The existing try/catch in `tryApiProvider` handles individual call failures by returning null (triggering chain fallback). Wrap just the RPC:
    ```typescript
    const resp = await summaryBreaker.execute(async () => {
      return newsClient.summarizeArticle({ ... });
    }, emptySummaryFallback);
    ```
    The `emptySummaryFallback` has `fallback: true`, so the existing check `if (resp.fallback) return null;` will naturally cause chain fallback when the breaker returns the default.

    ALSO wrap the `newsClient.summarizeArticle()` call in `translateText()` (line 229) with the same breaker:
    ```typescript
    const resp = await summaryBreaker.execute(async () => {
      return newsClient.summarizeArticle({ ... });
    }, emptySummaryFallback);
    ```

    **2. src/services/gdelt-intel.ts** (intelligence domain)

    Add import: `import { createCircuitBreaker } from '@/utils';`
    Import the response type: add `type SearchGdeltDocumentsResponse` to the existing import from the intelligence service client.
    Create breaker: `const gdeltBreaker = createCircuitBreaker<SearchGdeltDocumentsResponse>({ name: 'GDELT Intelligence' });`
    Define fallback: `const emptyGdeltFallback: SearchGdeltDocumentsResponse = { articles: [], error: '' };`

    In `fetchGdeltArticles()`, wrap the `client.searchGdeltDocuments()` call (currently line 118) inside `gdeltBreaker.execute()`. The existing function has try/catch with cache fallback on error. The breaker provides this automatically via `execute()`. Replace the try/catch:
    ```typescript
    const resp = await gdeltBreaker.execute(async () => {
      return client.searchGdeltDocuments({ query, maxRecords: maxrecords, timespan });
    }, emptyGdeltFallback);
    ```
    Then handle `resp.error` as before (return cached or empty). On success, map articles and update cache. The existing cache logic (`articleCache`) can coexist with the breaker's built-in cache -- the breaker's cache provides RPC-level fallback while `articleCache` provides query-specific deduplication. Keep both.
  </action>
  <verify>
    1. `grep -c 'createCircuitBreaker' src/services/summarization.ts` returns 1
    2. `grep -c 'createCircuitBreaker' src/services/gdelt-intel.ts` returns 1
    3. `grep 'summaryBreaker\|gdeltBreaker' src/services/summarization.ts src/services/gdelt-intel.ts` shows breaker usage
    4. `npx tsc --noEmit` passes
    5. All 17 domains now have circuit breakers. Verify: `grep -rl 'createCircuitBreaker' src/services/ | wc -l` should be >= 17 (some files have multiple breakers)
  </verify>
  <done>All 6 remaining domains now have circuit breaker coverage. CLIENT-03 is fully satisfied: 17/17 domains have createCircuitBreaker wrapping their sebuf client RPC calls.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `grep -rl 'createCircuitBreaker' src/services/` includes all 6 newly added files
3. No manual try/catch remains around sebuf client calls in the 4 direct-client files (seismology, wildfire, climate, maritime's proto path)
4. Maritime raw relay path (candidateReports) is NOT wrapped in a circuit breaker
5. Summarization fallback chain (Ollama -> Groq -> OpenRouter -> Browser T5) still works: breaker wraps individual RPC, not the chain
</verification>

<success_criteria>
All 17 domains have circuit breakers on their sebuf client RPC calls. TypeScript compiles. CLIENT-03 requirement is fully satisfied.
</success_criteria>

<output>
After completion, create `.planning/phases/04-v1-milestone-cleanup/04-02-SUMMARY.md`
</output>

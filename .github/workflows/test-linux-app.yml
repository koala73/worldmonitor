name: 'Test Linux App'

on:
  workflow_dispatch:

concurrency:
  group: test-linux-app-${{ github.ref }}
  cancel-in-progress: true

env:
  CARGO_REGISTRIES_CRATES_IO_PROTOCOL: sparse

jobs:
  test-linux-app:
    runs-on: ubuntu-24.04
    timeout-minutes: 120
    permissions:
      contents: read

    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5

      - name: Setup Node.js
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020
        with:
          node-version: '22'
          cache: 'npm'

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@631a55b12751854ce901bb631d5902ceb48146f7
        with:
          toolchain: stable

      - name: Rust cache
        uses: swatinem/rust-cache@ad397744b0d591a723ab90405b7247fac0e6b8db
        with:
          workspaces: './src-tauri -> target'
          cache-on-failure: true

      - name: Install Linux system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libappindicator3-dev \
            librsvg2-dev \
            patchelf \
            gstreamer1.0-plugins-base \
            gstreamer1.0-plugins-good \
            weston \
            xwayland \
            xvfb \
            imagemagick \
            xdotool

      - name: Install frontend dependencies
        run: npm ci

      - name: Bundle Node.js runtime
        shell: bash
        env:
          NODE_VERSION: '22.14.0'
          NODE_TARGET: 'x86_64-unknown-linux-gnu'
        run: bash scripts/download-node.sh --target "$NODE_TARGET"

      - name: Build Tauri app
        uses: tauri-apps/tauri-action@79c624843491f12ae9d63592534ed49df3bc4adb
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VITE_VARIANT: full
          VITE_DESKTOP_RUNTIME: '1'
          CONVEX_URL: ${{ secrets.CONVEX_URL }}
        with:
          args: ''
          retryAttempts: 1

      - name: Smoke-test AppImage
        shell: bash
        run: |
          APPIMAGE=$(find src-tauri/target/release/bundle/appimage -name '*.AppImage' | head -1)
          if [ -z "$APPIMAGE" ]; then
            echo "::error::No AppImage found after build"
            exit 1
          fi
          chmod +x "$APPIMAGE"

          # --- Try 1: Weston + XWayland ---
          # Weston provides a real compositor; XWayland gives GTK the X11 it needs.
          # This avoids the blank-screen problem of bare Xvfb.
          echo "=== Starting weston (headless + XWayland) ==="
          mkdir -p /tmp/weston-run
          export XDG_RUNTIME_DIR=/tmp/weston-run

          # Write a minimal weston.ini enabling XWayland
          cat > /tmp/weston-run/weston.ini <<'WINI'
          [core]
          xwayland=true
          WINI
          # Strip leading whitespace from heredoc
          sed -i 's/^[[:space:]]*//' /tmp/weston-run/weston.ini

          weston --backend=headless --config=/tmp/weston-run/weston.ini \
            --width=1440 --height=900 2>&1 | tee /tmp/weston.log &
          WESTON_PID=$!
          sleep 3

          WESTON_OK=false
          if kill -0 $WESTON_PID 2>/dev/null; then
            # Find the XWayland DISPLAY
            XWDISPLAY=$(grep -oP 'DISPLAY=:\K[0-9]+' /tmp/weston.log 2>/dev/null || echo "")
            if [ -n "$XWDISPLAY" ]; then
              export DISPLAY=":$XWDISPLAY"
              echo "XWayland running on DISPLAY=$DISPLAY"
              WESTON_OK=true
            else
              echo "Weston started but XWayland DISPLAY not found in logs"
              cat /tmp/weston.log || true
            fi
          else
            echo "Weston failed to start"
            cat /tmp/weston.log || true
          fi

          # --- Fallback: plain Xvfb ---
          if [ "$WESTON_OK" = "false" ]; then
            echo "=== Falling back to Xvfb ==="
            kill $WESTON_PID 2>/dev/null || true
            Xvfb :99 -screen 0 1440x900x24 &
            export DISPLAY=:99
            sleep 2
          fi

          # --- Launch AppImage ---
          echo "=== Launching AppImage on DISPLAY=$DISPLAY ==="
          GDK_BACKEND=x11 "$APPIMAGE" --no-sandbox 2>&1 | tee /tmp/app.log &
          APP_PID=$!
          sleep 20

          # --- Screenshot ---
          import -window root screenshot.png 2>/dev/null || true

          # --- Verify app is still running ---
          if kill -0 $APP_PID 2>/dev/null; then
            echo "✅ AppImage launched successfully (PID $APP_PID)"
          else
            echo "❌ AppImage crashed during startup"
            echo "--- App log ---"
            tail -50 /tmp/app.log || true
            exit 1
          fi

          # --- Check screenshot has non-black content ---
          if [ -f screenshot.png ]; then
            COLORS=$(identify -verbose screenshot.png 2>/dev/null | grep "Colors:" | awk '{print $2}')
            echo "Screenshot unique colors: ${COLORS:-unknown}"
            if [ "${COLORS:-0}" -le 5 ]; then
              echo "⚠️ Screenshot appears blank (only $COLORS colors). App may not have rendered."
            else
              echo "✅ Screenshot has content ($COLORS unique colors)"
            fi
          fi

          # --- Print app window info ---
          xdotool search --name "" getwindowname 2>/dev/null | head -5 || true

          kill $APP_PID 2>/dev/null || true
          kill $WESTON_PID 2>/dev/null || true

      - name: Upload smoke test screenshot
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: linux-smoke-test-screenshot
          path: screenshot.png
          if-no-files-found: warn

      - name: Upload logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: linux-smoke-test-logs
          path: |
            /tmp/weston.log
            /tmp/app.log
          if-no-files-found: warn
